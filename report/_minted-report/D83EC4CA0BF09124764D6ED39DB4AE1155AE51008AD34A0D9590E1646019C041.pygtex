\begin{Verbatim}[commandchars=\\\{\}]
\PYG{k+kn}{import} \PYG{n+nn}{java.util.*}\PYG{o}{;}

\PYG{k+kd}{public} \PYG{k+kd}{class} \PYG{n+nc}{CodeGenerator} \PYG{o}{\PYGZob{}}
	\PYG{k+kt}{int} \PYG{n}{labelCounter}\PYG{o}{;}
	\PYG{n}{Node} \PYG{n}{StatementList}\PYG{o}{;}
	\PYG{n}{SymbolTable} \PYG{n}{Table}\PYG{o}{;}
	\PYG{n}{ArrayList}\PYG{o}{\PYGZlt{}}\PYG{n}{Instruction}\PYG{o}{\PYGZgt{}} \PYG{n}{code}\PYG{o}{;}

	\PYG{c+cm}{/*}
\PYG{c+cm}{	 * The constructor of the code generator is passed a reference to the symbol}
\PYG{c+cm}{	 * table, and a reference to the statement list of the program}
\PYG{c+cm}{	 */}
	\PYG{k+kd}{public} \PYG{n+nf}{CodeGenerator}\PYG{o}{(}\PYG{n}{SymbolTable} \PYG{n}{table}\PYG{o}{,} \PYG{n}{Node} \PYG{n}{statementList}\PYG{o}{)} \PYG{o}{\PYGZob{}}
		\PYG{k}{this}\PYG{o}{.}\PYG{n+na}{Table} \PYG{o}{=} \PYG{n}{table}\PYG{o}{;}
		\PYG{k}{this}\PYG{o}{.}\PYG{n+na}{StatementList} \PYG{o}{=} \PYG{n}{statementList}\PYG{o}{;}
	\PYG{o}{\PYGZcb{}}

	\PYG{c+cm}{/*}
\PYG{c+cm}{	 * return the code generated by traversing the statement list that was}
\PYG{c+cm}{	 * passed to the constructor}
\PYG{c+cm}{	 */}
	\PYG{k+kd}{public} \PYG{n}{ArrayList}\PYG{o}{\PYGZlt{}}\PYG{n}{Instruction}\PYG{o}{\PYGZgt{}} \PYG{n+nf}{generateCode}\PYG{o}{()} \PYG{k+kd}{throws} \PYG{n}{Exception} \PYG{o}{\PYGZob{}}
		\PYG{n}{labelCounter} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
		\PYG{n}{code} \PYG{o}{=} \PYG{k}{new} \PYG{n}{ArrayList}\PYG{o}{\PYGZlt{}}\PYG{n}{Instruction}\PYG{o}{\PYGZgt{}();}
		\PYG{k}{this}\PYG{o}{.}\PYG{n+na}{generateStatementCode}\PYG{o}{(}\PYG{k}{this}\PYG{o}{.}\PYG{n+na}{StatementList}\PYG{o}{);}
		\PYG{k}{return} \PYG{n}{code}\PYG{o}{;}
	\PYG{o}{\PYGZcb{}}

	\PYG{k+kd}{private} \PYG{k+kt}{void} \PYG{n+nf}{generateStatementCode}\PYG{o}{(}\PYG{n}{Node} \PYG{n}{statement}\PYG{o}{)} \PYG{k+kd}{throws} \PYG{n}{Exception} \PYG{o}{\PYGZob{}}
		\PYG{k}{for} \PYG{o}{(;} \PYG{n}{statement} \PYG{o}{!=} \PYG{k+kc}{null}\PYG{o}{;} \PYG{n}{statement} \PYG{o}{=} \PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{Sibling}\PYG{o}{)} \PYG{o}{\PYGZob{}}
			\PYG{k}{switch} \PYG{o}{(}\PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{getType}\PYG{o}{())} \PYG{o}{\PYGZob{}}
			\PYG{k}{case} \PYG{n}{if\PYGZus{}keyword}\PYG{o}{:} \PYG{o}{\PYGZob{}}
				\PYG{c+cm}{/*}
\PYG{c+cm}{				 * generate code to evaluate the expression and}
\PYG{c+cm}{				 * store the result in t0}
\PYG{c+cm}{				 */}
				\PYG{k+kt}{int} \PYG{n}{expressionRegNum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
				\PYG{n}{generateExpressionCode}\PYG{o}{(}\PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{),}
						\PYG{n}{expressionRegNum}\PYG{o}{);}
				\PYG{n}{Instruction} \PYG{n}{exitIfLabel} \PYG{o}{=} \PYG{n}{newLabel}\PYG{o}{();}
				\PYG{n}{Instruction} \PYG{n}{exitIf} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
						\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{JumpZ}\PYG{o}{,}
						\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{expressionRegNum}\PYG{o}{),}
						\PYG{n}{exitIfLabel}\PYG{o}{.}\PYG{n+na}{getOperand}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{));}
				\PYG{c+cm}{/*}
\PYG{c+cm}{				 * add a conditional jump to exit label}
\PYG{c+cm}{				 */}
				\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{exitIf}\PYG{o}{);}
				\PYG{c+cm}{/*}
\PYG{c+cm}{				 * generate code for statements that are supposed}
\PYG{c+cm}{				 * to be executed when the expression evaluates}
\PYG{c+cm}{				 * to true}
\PYG{c+cm}{				 */}
				\PYG{n}{generateStatementCode}\PYG{o}{(}\PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{));}
				\PYG{k}{if} \PYG{o}{(}\PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{getChildrenCount}\PYG{o}{()} \PYG{o}{==} \PYG{l+m+mi}{3}\PYG{o}{)} \PYG{o}{\PYGZob{}}
					\PYG{c+cm}{/*}
\PYG{c+cm}{					 * if the if statement has an else part,}
\PYG{c+cm}{					 * generate code for it}
\PYG{c+cm}{					 */}
					\PYG{n}{Instruction} \PYG{n}{exitElseLabel} \PYG{o}{=} \PYG{n}{newLabel}\PYG{o}{();}
					\PYG{c+cm}{/*}
\PYG{c+cm}{					 * add a jump instruction (to skip the exit}
\PYG{c+cm}{					 * part in case the expression evaluated to}
\PYG{c+cm}{					 * true and the previous part was executed}
\PYG{c+cm}{					 */}
					\PYG{n}{Instruction} \PYG{n}{exitElse} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
							\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Jump}\PYG{o}{,}
							\PYG{n}{exitElseLabel}\PYG{o}{.}\PYG{n+na}{getOperand}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{));}
					\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{exitElse}\PYG{o}{);}
					\PYG{c+cm}{/*}
\PYG{c+cm}{					 * place the \PYGZsq{}if\PYGZsq{} exit label here (so the code}
\PYG{c+cm}{					 * will execute the else part if the expression}
\PYG{c+cm}{					 * evaluates to false and the jump is executed}
\PYG{c+cm}{					 */}
					\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{exitIfLabel}\PYG{o}{);}
					\PYG{c+cm}{/*}
\PYG{c+cm}{					 * generate code for the else part}
\PYG{c+cm}{					 */}
					\PYG{n}{generateStatementCode}\PYG{o}{(}\PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{2}\PYG{o}{));}
					\PYG{c+cm}{/*}
\PYG{c+cm}{					 * place the \PYGZsq{}else\PYGZsq{} exit label here}
\PYG{c+cm}{					 */}
					\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{exitElseLabel}\PYG{o}{);}
				\PYG{o}{\PYGZcb{}} \PYG{k}{else} \PYG{o}{\PYGZob{}}
					\PYG{c+cm}{/*}
\PYG{c+cm}{					 * if there is no else part, we just need to}
\PYG{c+cm}{					 * just place the \PYGZsq{}if\PYGZsq{} exit label here}
\PYG{c+cm}{					 */}
					\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{exitIfLabel}\PYG{o}{);}
				\PYG{o}{\PYGZcb{}}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{o}{\PYGZcb{}}
			\PYG{k}{case} \PYG{n}{while\PYGZus{}keyword}\PYG{o}{:} \PYG{o}{\PYGZob{}}
				\PYG{c+cm}{/*}
\PYG{c+cm}{				 * code for iteration statement uses labels in a way}
\PYG{c+cm}{				 * similar to that for selection statement}
\PYG{c+cm}{				 */}
				\PYG{n}{Instruction} \PYG{n}{enterLabel} \PYG{o}{=} \PYG{n}{newLabel}\PYG{o}{();}
				\PYG{n}{Instruction} \PYG{n}{exitLabel} \PYG{o}{=} \PYG{n}{newLabel}\PYG{o}{();}
				\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{enterLabel}\PYG{o}{);}
				\PYG{k+kt}{int} \PYG{n}{expressionRegNum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
				\PYG{n}{generateExpressionCode}\PYG{o}{(}\PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{),}
						\PYG{n}{expressionRegNum}\PYG{o}{);}
				\PYG{n}{Instruction} \PYG{n}{exitWhile} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
						\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{JumpZ}\PYG{o}{,}
						\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{expressionRegNum}\PYG{o}{),}
						\PYG{n}{exitLabel}\PYG{o}{.}\PYG{n+na}{getOperand}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{));}
				\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{exitWhile}\PYG{o}{);}
				\PYG{n}{generateStatementCode}\PYG{o}{(}\PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{));}
				\PYG{n}{Instruction} \PYG{n}{enterWhile} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
						\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Jump}\PYG{o}{,}
						\PYG{n}{enterLabel}\PYG{o}{.}\PYG{n+na}{getOperand}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{));} 
				\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{enterWhile}\PYG{o}{);}
				\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{exitLabel}\PYG{o}{);}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{o}{\PYGZcb{}}
			\PYG{k}{case} \PYG{n}{assignment\PYGZus{}operator}\PYG{o}{:} \PYG{o}{\PYGZob{}}
				\PYG{c+cm}{/* generate code to evaluate expression on right hand}
\PYG{c+cm}{				 * side and store it in register \PYGZsh{}valueRegNum}
\PYG{c+cm}{				 */}
				\PYG{k+kt}{int} \PYG{n}{valueRegNum} \PYG{o}{=} \PYG{l+m+mi}{0}\PYG{o}{;}
				\PYG{n}{generateExpressionCode}\PYG{o}{(}\PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{),}
						\PYG{n}{valueRegNum}\PYG{o}{);}
				\PYG{n}{Node} \PYG{n}{variable} \PYG{o}{=} \PYG{n}{statement}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{);}
				\PYG{c+cm}{/* the following code finds the memory location}
\PYG{c+cm}{				 * of the variable on the left hand side, and}
\PYG{c+cm}{				 * adds a \PYGZsq{}store\PYGZsq{} instruction to store the value}
\PYG{c+cm}{				 * computed previously in that location}
\PYG{c+cm}{				 */}
				\PYG{k}{if} \PYG{o}{(}\PYG{n}{variable}\PYG{o}{.}\PYG{n+na}{getType}\PYG{o}{()} \PYG{o}{==} \PYG{n}{TokenType}\PYG{o}{.}\PYG{n+na}{square\PYGZus{}bracket}\PYG{o}{)} \PYG{o}{\PYGZob{}}
					\PYG{k+kt}{int} \PYG{n}{addressRegNum} \PYG{o}{=} \PYG{l+m+mi}{1}\PYG{o}{;}
					\PYG{k+kt}{int} \PYG{n}{offsetRegNum} \PYG{o}{=} \PYG{l+m+mi}{2}\PYG{o}{;}
					\PYG{n}{Node} \PYG{n}{id} \PYG{o}{=} \PYG{n}{variable}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{);}
					\PYG{n}{Node} \PYG{n}{expression} \PYG{o}{=} \PYG{n}{variable}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{);}
					\PYG{c+cm}{/*}
\PYG{c+cm}{					 * generate code to compute the expression}
\PYG{c+cm}{					 * representing the array index, and store}
\PYG{c+cm}{					 * its value in register \PYGZsh{}offsetRegNum}
\PYG{c+cm}{					 */}
					\PYG{n}{generateExpressionCode}\PYG{o}{(}\PYG{n}{expression}\PYG{o}{,} \PYG{n}{offsetRegNum}\PYG{o}{);}
					\PYG{c+cm}{/*}
\PYG{c+cm}{					 * generate code to assign value of register}
\PYG{c+cm}{					 * \PYGZsh{}addressRegNum to the base address of the}
\PYG{c+cm}{					 * variable}
\PYG{c+cm}{					 * }
\PYG{c+cm}{					 * base address is a static attribute that}
\PYG{c+cm}{					 * is obtained from the symbol table}
\PYG{c+cm}{					 */}
					\PYG{n}{Instruction} \PYG{n}{assign} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
							\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Assign}\PYG{o}{,}
							\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{addressRegNum}\PYG{o}{),}
							\PYG{n}{address}\PYG{o}{(}\PYG{n}{id}\PYG{o}{));} 
					\PYG{c+cm}{/*}
\PYG{c+cm}{					 * generate code to multiply offset by}
\PYG{c+cm}{					 * the size of an array element of this}
\PYG{c+cm}{					 * type}
\PYG{c+cm}{					 * }
\PYG{c+cm}{					 * size of an array element is a static}
\PYG{c+cm}{					 * attribute that is obtained from the}
\PYG{c+cm}{					 * symbol table}
\PYG{c+cm}{					 */}
					\PYG{n}{Instruction} \PYG{n}{mul} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
							\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Mul}\PYG{o}{,}
							\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{offsetRegNum}\PYG{o}{),}
							\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{offsetRegNum}\PYG{o}{),}
							\PYG{n}{size}\PYG{o}{(}\PYG{n}{id}\PYG{o}{)}
							\PYG{o}{);}
					\PYG{n}{Instruction} \PYG{n}{add} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
							\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Add}\PYG{o}{,}
							\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{addressRegNum}\PYG{o}{),}
							\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{addressRegNum}\PYG{o}{),}
							\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{offsetRegNum}\PYG{o}{));} 
					\PYG{n}{Instruction} \PYG{n}{store} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
							\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Store}\PYG{o}{,}
							\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{addressRegNum}\PYG{o}{),}
							\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{valueRegNum}\PYG{o}{));}
					\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{assign}\PYG{o}{);}
					\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{mul}\PYG{o}{);}
					\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{add}\PYG{o}{);}
					\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{store}\PYG{o}{);}
				\PYG{o}{\PYGZcb{}} \PYG{k}{else} \PYG{o}{\PYGZob{}}
					\PYG{n}{Instruction} \PYG{n}{store} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
							\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Store}\PYG{o}{,}
							\PYG{n}{address}\PYG{o}{(}\PYG{n}{variable}\PYG{o}{),}
							\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{valueRegNum}\PYG{o}{));}
					\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{store}\PYG{o}{);}
				\PYG{o}{\PYGZcb{}}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{o}{\PYGZcb{}}
			\PYG{o}{\PYGZcb{}}
		\PYG{o}{\PYGZcb{}}
	\PYG{o}{\PYGZcb{}}

	\PYG{c+cm}{/*}
\PYG{c+cm}{	 * this function generates code to be evaluate the expression}
\PYG{c+cm}{	 * represented by the passed syntax tree node, and stores its}
\PYG{c+cm}{	 * value in temporary register \PYGZsh{}returnRegNum}
\PYG{c+cm}{	 */}
	\PYG{k+kd}{private} \PYG{k+kt}{void} \PYG{n+nf}{generateExpressionCode}\PYG{o}{(}\PYG{n}{Node} \PYG{n}{node}\PYG{o}{,} \PYG{k+kt}{int} \PYG{n}{returnRegNum}\PYG{o}{)}
			\PYG{k+kd}{throws} \PYG{n}{Exception} \PYG{o}{\PYGZob{}}
		\PYG{k}{switch} \PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{getType}\PYG{o}{())} \PYG{o}{\PYGZob{}}
		\PYG{k}{case} \PYG{n}{addition\PYGZus{}operator}\PYG{o}{:}
		\PYG{k}{case} \PYG{n}{multiplication\PYGZus{}operator}\PYG{o}{:}
		\PYG{k}{case} \PYG{n}{relational\PYGZus{}operator}\PYG{o}{:} \PYG{o}{\PYGZob{}}
			\PYG{k+kt}{int} \PYG{n}{leftValueRegNum} \PYG{o}{=} \PYG{n}{returnRegNum} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{;}
			\PYG{k+kt}{int} \PYG{n}{rightValueRegNum} \PYG{o}{=} \PYG{n}{returnRegNum} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{;}
			\PYG{c+c1}{// if the expression is an operator, generate code}
			\PYG{c+c1}{// over the following 3 steps:}
			\PYG{c+c1}{// 1. generate code to store the value of the left child in}
			\PYG{c+c1}{// register \PYGZsh{}leftValueRegNum}
			\PYG{n}{generateExpressionCode}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{),} \PYG{n}{leftValueRegNum}\PYG{o}{);}
			\PYG{c+c1}{// 2. generate code to store the value of the right child in}
			\PYG{c+c1}{// register \PYGZsh{}rightValueRegNum}
			\PYG{n}{generateExpressionCode}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{),} \PYG{n}{rightValueRegNum}\PYG{o}{);}
			\PYG{c+c1}{// 3. add an instruction to combine the result of the left}
			\PYG{c+c1}{// child and right child; first find the operator type, and}
			\PYG{c+c1}{// then add the instruction}
			\PYG{n}{InstructionType} \PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Add}\PYG{o}{;}
			\PYG{k}{switch} \PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{getLexim}\PYG{o}{())} \PYG{o}{\PYGZob{}}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}+\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Add}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}\PYGZhy{}\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Sub}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}*\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Mul}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}/\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Div}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}\PYGZlt{}=\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{SetLE}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}\PYGZgt{}=\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{SetGE}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}==\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{SetE}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}!=\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{SetNE}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}\PYGZlt{}\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{SetL}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{k}{case} \PYG{l+s}{\PYGZdq{}\PYGZgt{}\PYGZdq{}}\PYG{o}{:}
				\PYG{n}{t} \PYG{o}{=} \PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{SetG}\PYG{o}{;}
				\PYG{k}{break}\PYG{o}{;}
			\PYG{o}{\PYGZcb{}}
			\PYG{n}{Instruction} \PYG{n}{operation} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}\PYG{n}{t}\PYG{o}{,}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{returnRegNum}\PYG{o}{),}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{leftValueRegNum}\PYG{o}{),}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{rightValueRegNum}\PYG{o}{));}
			\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{operation}\PYG{o}{);}
			\PYG{k}{break}\PYG{o}{;}
		\PYG{o}{\PYGZcb{}}
		\PYG{k}{case} \PYG{n}{integer\PYGZus{}literal}\PYG{o}{:}
		\PYG{k}{case} \PYG{n}{real\PYGZus{}literal}\PYG{o}{:} \PYG{o}{\PYGZob{}}
			\PYG{c+c1}{// if the expression is just a constant, directly}
			\PYG{c+c1}{// store its value in the register}
			\PYG{n}{Instruction} \PYG{n}{assign} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}
					\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Assign}\PYG{o}{,}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{returnRegNum}\PYG{o}{),}
					\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{getLexim}\PYG{o}{());}
			\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{assign}\PYG{o}{);}
			\PYG{k}{break}\PYG{o}{;}
		\PYG{o}{\PYGZcb{}}
		\PYG{k}{case} \PYG{n}{identifier}\PYG{o}{:} \PYG{o}{\PYGZob{}}
			\PYG{c+c1}{// if the expression is a variable, load its value}
			\PYG{c+c1}{// from memory to the register}
			\PYG{n}{Instruction} \PYG{n}{load} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Load}\PYG{o}{,}
					\PYG{n}{address}\PYG{o}{(}\PYG{n}{node}\PYG{o}{),}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{returnRegNum}\PYG{o}{));}
			\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{load}\PYG{o}{);}
			\PYG{k}{break}\PYG{o}{;}
		\PYG{o}{\PYGZcb{}}
		\PYG{k}{case} \PYG{n}{square\PYGZus{}bracket}\PYG{o}{:} \PYG{o}{\PYGZob{}}
			\PYG{k+kt}{int} \PYG{n}{addressRegNum} \PYG{o}{=} \PYG{n}{returnRegNum} \PYG{o}{+} \PYG{l+m+mi}{1}\PYG{o}{;}
			\PYG{k+kt}{int} \PYG{n}{offsetRegNum} \PYG{o}{=} \PYG{n}{returnRegNum} \PYG{o}{+} \PYG{l+m+mi}{2}\PYG{o}{;}
			\PYG{c+c1}{// if the expression is an array element, compute}
			\PYG{c+c1}{// its address first and then load the value from}
			\PYG{c+c1}{// memory into the return register}
			\PYG{n}{generateExpressionCode}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{1}\PYG{o}{),}
					\PYG{n}{offsetRegNum}\PYG{o}{);}
			\PYG{n}{Instruction} \PYG{n}{assign} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Assign}\PYG{o}{,}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{addressRegNum}\PYG{o}{),}
					\PYG{n}{address}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{)));}
			\PYG{n}{Instruction} \PYG{n}{mul} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Mul}\PYG{o}{,}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{offsetRegNum}\PYG{o}{),}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{offsetRegNum}\PYG{o}{),}
					\PYG{n}{size}\PYG{o}{(}\PYG{n}{node}\PYG{o}{.}\PYG{n+na}{getChild}\PYG{o}{(}\PYG{l+m+mi}{0}\PYG{o}{)));}
			\PYG{n}{Instruction} \PYG{n}{add} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Add}\PYG{o}{,}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{addressRegNum}\PYG{o}{),}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{addressRegNum}\PYG{o}{),}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{offsetRegNum}\PYG{o}{));}
			\PYG{n}{Instruction} \PYG{n}{load} \PYG{o}{=} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Load}\PYG{o}{,}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{addressRegNum}\PYG{o}{),}
					\PYG{n}{tmpReg}\PYG{o}{(}\PYG{n}{returnRegNum}\PYG{o}{));}
			\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{assign}\PYG{o}{);}\PYG{c+c1}{// assign base address address}
			\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{mul}\PYG{o}{);}	\PYG{c+c1}{// multiply offset by element size}
			\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{add}\PYG{o}{);}	\PYG{c+c1}{// increment address}
			\PYG{n}{code}\PYG{o}{.}\PYG{n+na}{add}\PYG{o}{(}\PYG{n}{load}\PYG{o}{);}	\PYG{c+c1}{// load from memory}
			\PYG{k}{break}\PYG{o}{;}
		\PYG{o}{\PYGZcb{}}
		\PYG{o}{\PYGZcb{}}
	\PYG{o}{\PYGZcb{}}
	\PYG{c+cm}{/*}
\PYG{c+cm}{	 * the following function creates a new label}
\PYG{c+cm}{	 */}
	\PYG{k+kd}{private} \PYG{n}{Instruction} \PYG{n+nf}{newLabel}\PYG{o}{()}
	\PYG{o}{\PYGZob{}}
		\PYG{k}{return} \PYG{k}{new} \PYG{n}{Instruction}\PYG{o}{(}\PYG{n}{InstructionType}\PYG{o}{.}\PYG{n+na}{Label}\PYG{o}{,}
				\PYG{l+s}{\PYGZdq{}L\PYGZdq{}} \PYG{o}{+} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{toString}\PYG{o}{(}\PYG{n}{labelCounter}\PYG{o}{++));}
	\PYG{o}{\PYGZcb{}}
	\PYG{c+cm}{/*}
\PYG{c+cm}{	 * I have only used the following function to eliminate pieces of code that}
\PYG{c+cm}{	 * are repeated multiple times. This code just returns a string representing}
\PYG{c+cm}{	 * some type of operands of the instructions}
\PYG{c+cm}{	 */}
	\PYG{k+kd}{private} \PYG{n}{String} \PYG{n+nf}{address}\PYG{o}{(}\PYG{n}{Node} \PYG{n}{id}\PYG{o}{)} \PYG{k+kd}{throws} \PYG{n}{Exception} \PYG{o}{\PYGZob{}}
		\PYG{c+c1}{// passed a node representing a variable, return its address}
		\PYG{k}{return} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{toString}\PYG{o}{(}\PYG{k}{this}\PYG{o}{.}\PYG{n+na}{Table}\PYG{o}{.}\PYG{n+na}{lookUp}\PYG{o}{(}\PYG{n}{id}\PYG{o}{.}\PYG{n+na}{getLexim}\PYG{o}{())}
				\PYG{o}{.}\PYG{n+na}{getRelativeAddress}\PYG{o}{());}
	\PYG{o}{\PYGZcb{}}
	\PYG{k+kd}{private} \PYG{n}{String} \PYG{n+nf}{size}\PYG{o}{(}\PYG{n}{Node} \PYG{n}{id}\PYG{o}{)} \PYG{k+kd}{throws} \PYG{n}{Exception} \PYG{o}{\PYGZob{}}
		\PYG{c+c1}{// passed a node representing a variable, return its entity size}
		\PYG{k}{return} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{toString}\PYG{o}{(}\PYG{k}{this}\PYG{o}{.}\PYG{n+na}{Table}\PYG{o}{.}\PYG{n+na}{lookUp}\PYG{o}{(}\PYG{n}{id}\PYG{o}{.}\PYG{n+na}{getLexim}\PYG{o}{())}
				\PYG{o}{.}\PYG{n+na}{getType}\PYG{o}{().}\PYG{n+na}{getSize}\PYG{o}{());}
	\PYG{o}{\PYGZcb{}}

	\PYG{k+kd}{private} \PYG{n}{String} \PYG{n+nf}{tmpReg}\PYG{o}{(}\PYG{k+kd}{final} \PYG{k+kt}{int} \PYG{n}{idx}\PYG{o}{)} \PYG{o}{\PYGZob{}}
		\PYG{c+c1}{// return a string representing a temporary register}
		\PYG{k}{return} \PYG{l+s}{\PYGZdq{}t\PYGZdq{}} \PYG{o}{+} \PYG{n}{Integer}\PYG{o}{.}\PYG{n+na}{toString}\PYG{o}{(}\PYG{n}{idx}\PYG{o}{);}
	\PYG{o}{\PYGZcb{}}
\PYG{o}{\PYGZcb{}}
\end{Verbatim}
